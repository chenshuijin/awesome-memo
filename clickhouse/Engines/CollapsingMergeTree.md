# CollapsingMergeTree

此引擎与MergeTree 的不同之处在于，它允许在合并时自动删除或'折叠(collapsing)'某些行。

Yandex.Metrica有一些正常日志(如hit log)和change log。Change log用于增量计算不断更改的数据的统计信息。例如会话更改日志或用户历史记录更改日志。
Yandex.Metrica中的会话总是不断变化。例如，每个会话的命中数会增加。我们将任何对象中的更改称为一对(?旧值?新值)。如果创建了对象，则可能缺少旧值。
如果删除了对象，则可能缺少新值。如果对象已更改，但以前存在且未删除，则两个值都存在。在更改日志中，为每个更改创建一个或两个条目。
每个条目都包含对象具有的所有属性，以及用于区分新旧值的特殊属性。当对象发生更改时，仅将新条目添加到更改日志中，现有条目不会被触及。

通过change log，可以增量计算几乎所有统计信息。为此，我们需要考虑带加号的"new"行和带减号的"old"行。
换句话说，对于代数结构包含用于取元素的逆的操作的所有统计信息，增量计算都是可能的。大多数统计数据都是这样。
我们还可以计算“幂等”统计信息，如唯一访问者的数量，因为在更改会话时不会删除唯一访问者。

这是允许 Yandex.Metrica 进行实时工作的主要概念。

CollapsingMergeTree 接受一个附加参数-- int8类型的列，其包含该行的'sign'。例子:
```
CollapsingMergeTree(EventDate, (CounterID, EventDate, intHash32(UniqID), VisitID), 8192, Sign)

```
在这里，'Sign'是一个对旧值用-1对新值用1的列。

在合并时，每个连续相同的主键(排序数据的列)的每组减少到不超过一行，列值“sign_column = -1”(“负行”)，且不超过一行与列值"sign_column = 1"(“正行”)。
换句话说，change log中的条目被折叠了。
如果正和负行的数目匹配，则写入第一个负行和最后一个正行。如果有正行比负行的数量多，则只写入最后一行。如果负行的比正行的数量多，则只写入第一个负行。
否则，就会有逻辑错误，不会写入任何行。(如果日志中的同一部分意外插入了一次以上，则可能发生逻辑错误。错误仅记录在服务器日志中，合并继续。)

因此，'折叠'不应更改统计信息的计算结果。变更会逐渐折叠，以便最后只剩下几乎每个object的最后值。
与MergeTree相比，CollapsingMergeTree 引擎支持多种形式的数据量减少。

有多种方法可以从CollapsingMergeTree 表中获得完全“折叠”的数据:
编写包含GROUPBY和aggregate函数的查询，这些函数用于解释sign。
例如，
* 要计算数量，请写入“sum(Sign)”而不是“count()”
* 要计算某事物的总和，请写“sum(Sign * x)”而不是“sum(x)”
* 依此类推，并加上“HAVING sum(Sign) > 0”

并非所有数字都可以这样计算。例如，无法重写聚合函数“min”和“max”。
如果必须提取数据而不进行聚合(例如，检查是否存在最新值与特定条件匹配的行)，则可以在FROM子句中用FINAL修饰符。这种方法效率要低得多。


