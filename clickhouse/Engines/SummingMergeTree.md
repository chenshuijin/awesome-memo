# SummingMergeTree

此引擎与MergeTree的不同之处在于，它在合并时汇总数据。

```
SummingMergeTree(EventDate, (OrderID, EventDate, BannerID, ...), 8192)
```
要合计的列是隐式的。合并时，具有相同主键值的所有行(在示例中为OrderId、eventdate、BannerID，...)进行汇总，并且不在主键中。


```
SummingMergeTree(EventDate, (OrderID, EventDate, BannerID, ...), 8192, (Shows, Clicks, Cost, ...))
```
要合计的列是显式设置的(最后一个参数 -Shows, Clicks, Cost, ...)中。
合并时，具有相同主键的所有行在指定列中汇总。指定的列也必须是numeric(数字)类型的，并且不能是主键的一部分。


如果所有这些列中的值都为null，则将删除行。(例外的情况是数据part中没有任何行。

对于不属于主键的其他行，合并时将选择出现的第一个值。

不对读取操作执行求和。如有必要，请编写相应的GROUP BY。


此外，表可以具有以特殊方式处理的嵌套数据结构。
如果嵌套表的名称以“Map”结尾，并且它至少包含两个满足以下条件的列: *对于第一个表，numeric ((U)IntN, Date, DateTime)，
我们将对于其他表把他称为“key”*，arithmetic ((U)IntN, Float32/64)，我们将将其称为“(值...) '

然后，将此嵌套表解释为key => (values...)，并且当合并其行时，两个数据集的元素通过“key”与相应的(值...)中。

例子
```
[(1, 100)] + [(2, 150)] -> [(1, 100), (2, 150)]
[(1, 100)] + [(1, 150)] -> [(1, 250)]
[(1, 100)] + [(1, 150), (2, 150)] -> [(1, 250), (2, 150)]
[(1, 100), (2, 150)] + [(1, -100)] -> [(2, 150)]
```
对聚合映射, 使用函数sumMap(key, value)。

对于嵌套数据结构，不需要指定需要汇总的列。

这种表引擎并不特别有用。请记住，在保存预聚合数据时，您将失去系统上的一些优势。

